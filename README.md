# Sensitivity-Maps-with-Machine-Learning или Исследование подходов к созданию карт чувствительности катушек из неполного к-пространства МРТ

Investigation of approaches to creating coil sensitivity maps from incomplete MRI k-space

Проект посвящён исследованию различных методов построения **карт чувствительности МРТ катушек** и их влияния на качество реконструкции изображений.

## Структура проекта

1. Способы комбинирования катушек при подготовке эталонов карт чувствительности
2. Подходы к созданию карт чувствительности катушек из автокалибровочного сигнала (АCS)

   2.1. Прямой метод (к-пространство – FFT – SOS)

   2.2. ESPIRiT

   2.3. DL
3. Подходы к созданию карт чувствительности катушек из прореженного центра к-пространства

   3.1. JSense

   3.2. DL
4. Влияния метода создания карт чувствительности на качество реконструкции МРТ

## Описание реализации проекта

### Methods.Math

В директории содержатся файлы с реализацией математических алгоритмов создания карт чувствительности.

Каждый файл можно разделить на 3 функции:

`ifft2c(k)` - функция отвечающая за Быстрое преобразование Фурье (со сдвигом), принимающая к-пространство, выдающая изображение

`sum_of_squares(k)` - или другая функция отвечающая за сам метод, принимает к-пространство, по ним высчитывает карту чувствительности и возвращает ее

`vizual(k, s)` - функция визуализации разности истинной карты чувствительности и смоделированной методом. Принимает к-пространство, по которому будет посчитана карта чувствиетльности, и истинную карту чувствительности, чтобы по ней сравнить

Если запустить сам файл метода, то будет вызван проводник для выбора к-пространства и истинной карты чувствительности и вызвана функция `vizual(k, s)`.

**Реализованы методы:**

* SOS = сумма квадратов амплитуд `Sos.py`
* KontrolCoil = комбинирование с использованием опорной катушки `KontrolCoil.py`
* GeometryWeight = геометрическое среднее или взвешенное объединение `Geometry.py`
* PhaseConsistency = использование фазовой согласованности `Phase.py`

Так как для сравнительного анализа могут пригодиться результаты выполнения, был создан `Saver`.

Выбрав метод, запускаются фунции по созданию карт чувствительности данным методом (необходимо будет выбрать к-пространство). Результат будет сохранен в папку `Data` с именем файла, содержащий в названии название метода и информацию о к-пространстве `sos_map_k_space_1.npy`.

### Methods.Espirit

Алгоритм, который используется в параллельном сканировании. Основан на центральных строчках к-пространства, по которым считает карты чувствительности.

Реализация алгоритма взаимствована с другого проекта `FITP-Projects-Image-Reconstruction`.

До строки `======= Использование =======` код перенесен с проекта ФИТиПа. По аналогии с `Msth` функциями была реализована функция `vizual(kspace)`.

### Methods.Jsense

JSENSE (Joint estimation of SENSE maps and image) — это итеративный метод, который одновременно восстанавливает изображение и карты чувствительности. Алгоритм расширяет классическую схему SENSE, в которой карты чувствительности считаются заранее. Используется при исследовании, при котором пациент не может быть неподвижен. Начальная карта рассчитывается по SOS.

Структурная реализация файла напоминает `Math` методы.

### Models

В директории содержатся файлы с реализацией "оберточных" над моделями классами. С помощью этих классов возможно повторное обучение моделей, визуализация сравнения с истинными картами чувствиетльности, сохранение результатов.

Каждый из классов моделей можно описать таким интерфейсом:

```py
class MLModel:
    def __init__(self, dataset_path, model_name, *args):
    def load_data(self, test_size):
    def train(self):
    def predict_on_file(self, kspace_path, sens_path, save_dir):
    def show_comparison(self, true_map, pred_map, title):

```

Названия методов класса говорят сами за себя как и их аргументы.

В качестве моделей `sklearn` были взяты:

* Ridge
* Random Forest
* Hist Gradient Boosting
* Bayesian Ridge
* K Neighbors Regressor

Для удобного повторного использования моделей было реализовано мини-приложение `Models.UniModelVizual.py`, где можно выбрать датасет, на котором будет обучаться выбранная модель. В результате будет сохранен предсказанный файл `.npy` для выбранного файла с к-пространством.

![image.png](assets/image.png?t=1747524107444)

## Результаты

Что касается результатов DL-model, то они предсказывают мягко говоря не очень хорошо:


| Модель  | k_space_1 | k_space_2 | k_space_3 | k_space_4 | Средний MSE |
| ------------- | --------- | --------- | --------- | --------- | ------------------ |
| bayesianridge | 0.083329  | 0.083329  | 0.083328  | 0.083329  | 0.083329           |
| knn           | 0.075906  |    0.004406  |   0.022003  | 0.081812  | 0.046032      |
| randomforest  | 0.010618  |   0.010596   |  0.032113  |  0.032233  | 0.021390     |
| histgb        | 0.083214  | 0.083294  | 0.083320  |   0.083258   | 0.083271     |
| ridge         | 0.083329  | 0.083328  | 0.083328  | 0.083329  | 0.083329           |

Если смотреть на результаты выполнения по времени и по качеству всех методов, то:


| Название                                               | Время работы                | Точность изображения                      |
| -------------------------------------------------------------- | -------------------------------------- | ------------------------------------------------------------ |
| Эталонные карты чувствительности | От 0.2 с до 18.3 с               | ~76%                                                         |
| Ridge                                                          | От 15.2 с до 10.3 мин          | ~0%                                                          |
| RandomForestRegressor                                          | От 15.4 мин до 48.2 мин      | ~54%                                                         |
| KNeighborsRegressor                                            | От 33.2 мин до 3 ч 27.1 мин | ~20-57%  <br /><br />Хуже на прореженном. |
| HistGradientBoosting                                           | От 20.1 с до 45.2 с              | ~+0%                                                         |
| BayesianRidge                                                  | От 17.3 с до 37.5 с              | ~0%                                                          |
| JSense                                                         | От 8.0 с до 19.3 с               | ~69%                                                         |
| ESPIRiT                                                        | От 38.4 с до 1.5 мин           | ~47%                                                         |

## Используемые технологии

- Python, NumPy, Matplotlib
- Scikit-learn (Ridge, RandomForestRegressor, KNeighborsRegressor, HistGradientBoosting, BayesianRidge)

---

## Запуск проекта

Проект может быть использован по частям, как работают каждые из частей можно ознакомиться в разделе **Описание реализации проекта**.

## Автор

Телеграмм: https://t.me/gedrargerym
